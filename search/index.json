[{"content":"前言 公司使用互联网每天最头疼的事莫过于联网还得登录。作为一个懒人，如此的重复劳动属实是不能接受的。为了解决这个问题，想着部署单点登录无奈推进坎坷。没办法先搞个web联网认证自动脚本吧。\nWeb登录页面分析 第一步就是得弄明白报文的地址和格式，然后只需要让代码替代请求即可完成。使用Chrome浏览器打开认证登陆界面按下F12打开网络解析器，勾选Preverse log选项。输入账号密码登录，对登录请求进行分析。可以看到，我们按下登录按钮后，网络请求资源中有一个login登录请求。我们点击它，详细信息在右边显示，包括请求头、返回头、payload、cookies等信息。我们最关注的是payload里提交的信息，这里记录我们的账号密码等信息，点击查看一下：\n这里payload的表单信息包括页面版本、登陆账号、登录密码、语言等信息。但，这个password这么一长串，也不是我输入的密码啊？这是森马加密方法呢？有点难搞。我来尝试重新登录下。哎，密文没有变。好好好分析下从登陆界面开始到登陆成功为止，很明显是从login先开始的，这里的密码已经加密了。在这之前我也没输入过密码。所以，”心机之蛙，一直摸你肚子“，密码是在前端直接加密了！是在我按下登陆的同时前端实时加密然后再上传的。\n这不So easy， JS代码里肯定有加密代码。\n妈蛋，还分析个6啊请求资源列表里这不摆着crypt.js加密嘛。我这眼镜白带了。那么好我们来打开看下： 是个Md6？哈希密码？不管了有了方法就好办了。\nPyCharm启动（写脚本） 二半吊子写py，过程极其坎坷直接上完整代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 # -*- coding: utf-8 -*- # @Author : N10 # @Email : dp7100@126.com # @Software: PyCharm import msvcrt import requests import json import os # 使cmd能够正确输出颜色 if os.name == \u0026#34;nt\u0026#34;: os.system(\u0026#34;\u0026#34;) # 切换工作目录到系统临时文件区域 os.chdir(os.getenv(\u0026#39;TMP\u0026#39;)) # 文件名称 file_name = \u0026#34;user_account.json\u0026#34; # md6加密函数 - 根据前端crypt.js实现 def md6(s: str) -\u0026gt; str: \u0026#34;\u0026#34;\u0026#34;完全匹配前端crypt.js的md6函数实现\u0026#34;\u0026#34;\u0026#34; def mc(a: int) -\u0026gt; str: a = a \u0026amp; 0xFF # 确保a是无符号8位整数 b = \u0026#34;0123456789ABCDEF\u0026#34; if a == ord(\u0026#39; \u0026#39;): return \u0026#39;+\u0026#39; elif (a \u0026lt; ord(\u0026#39;0\u0026#39;) and a != ord(\u0026#39;-\u0026#39;) and a != ord(\u0026#39;.\u0026#39;)) or \\ (a \u0026lt; ord(\u0026#39;A\u0026#39;) and a \u0026gt; ord(\u0026#39;9\u0026#39;)) or \\ (a \u0026gt; ord(\u0026#39;Z\u0026#39;) and a \u0026lt; ord(\u0026#39;a\u0026#39;) and a != ord(\u0026#39;_\u0026#39;)) or \\ (a \u0026gt; ord(\u0026#39;z\u0026#39;)): return f\u0026#34;%{b[(a \u0026gt;\u0026gt; 4) \u0026amp; 0xF]}{b[a \u0026amp; 0xF]}\u0026#34; else: return chr(a) def m(a: int) -\u0026gt; int: return ( ((a \u0026amp; 1) \u0026lt;\u0026lt; 7) | ((a \u0026amp; 0x2) \u0026lt;\u0026lt; 5) | ((a \u0026amp; 0x4) \u0026lt;\u0026lt; 3) | ((a \u0026amp; 0x8) \u0026lt;\u0026lt; 1) | ((a \u0026amp; 0x10) \u0026gt;\u0026gt; 1) | ((a \u0026amp; 0x20) \u0026gt;\u0026gt; 3) | ((a \u0026amp; 0x40) \u0026gt;\u0026gt; 5) | ((a \u0026amp; 0x80) \u0026gt;\u0026gt; 7) ) \u0026amp; 0xFF # 确保结果在0-255范围内 result = \u0026#34;\u0026#34; c = 0xbb for i in range(len(s)): a = ord(s[i]) ma = m(a) mask = i \u0026amp; 0xff xor = 0x35 ^ mask c = (ma ^ xor) \u0026amp; 0xFF # 关键：确保c是无符号8位整数 result += mc(c) return result # 检查是否需要输入账号密码，如果不存在临时文件，根据输入新建临时文件保存账号密码。 if not os.path.exists(file_name): # 输入账号密码 account = input(\u0026#34;请输入你的账号: \u0026#34;) password = input(\u0026#34;请输入你的密码: \u0026#34;) # 对密码进行哈希处理 hashed_password = md6(password) # 保存账号和哈希后的密码 res = { \u0026#39;account\u0026#39;: account, \u0026#39;password\u0026#39;: hashed_password } print(\u0026#34;已安全保存账号信息\u0026#34;, res) # 写入json with open(file_name, \u0026#34;w+\u0026#34;) as fp: fp.write(json.dumps(res)) # 如果存在，说明之前已经写入 else: # 读取账号和哈希后的密码 with open(file_name, \u0026#34;r\u0026#34;) as fp: res = json.loads(fp.read()) account = res[\u0026#39;account\u0026#39;] hashed_password = res[\u0026#39;password\u0026#39;] # 明确这是哈希后的密码 print(f\u0026#34;已读取保存的账号: {account}\u0026#34;) # 请求网址 url = \u0026#34;http://10.1.1.10/login\u0026#34; #认证页面地址。 # 请求头 headers = { \u0026#34;X-Requested-With\u0026#34;: \u0026#34;XMLHttpRequest\u0026#34;, \u0026#34;User-Agent\u0026#34;: \u0026#34;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/97.0.4692.71 Safari/537.36\u0026#34;, \u0026#34;Content-Type\u0026#34;: \u0026#34;application/x-www-form-urlencoded; charset=UTF-8\u0026#34;, # 必须指定，否则报404 } print(\u0026#34;\\n正在尝试互联网登录认证...\u0026#34;) while True: try: # 直接使用从文件中读取的哈希值 encrypted_pwd = hashed_password # 打印发送的加密密码（调试用） # print(f\u0026#34;发送的加密密码: {encrypted_pwd}\u0026#34;) # 构建登录请求参数 payload = f\u0026#34;page_version=10.0\u0026amp;username={account}\u0026amp;password={encrypted_pwd}\u0026amp;login_type=login\u0026amp;page_language=zh\u0026amp;terminal=pc\u0026amp;uri=换成你的uri地址\u0026#34; # 发送登录请求 res = requests.post(url, data=payload, headers=headers) # 打印响应内容（调试用） # print(f\u0026#34;响应状态码: {res.status_code}\u0026#34;) # print(f\u0026#34;响应内容: {res.text}\\n\u0026#34;) # 判断登录是否成功 failed_keywords = [\u0026#34;登录失败\u0026#34;, \u0026#34;error\u0026#34;, \u0026#34;账号或密码错误\u0026#34;, \u0026#34;认证失败\u0026#34;, \u0026#34;账号或者密码错误\u0026#34;] success_keywords = [\u0026#34;success\u0026#34;, \u0026#34;欢迎\u0026#34;, \u0026#34;认证成功\u0026#34;, \u0026#34;登录成功\u0026#34;] has_failed = any(keyword in res.text for keyword in failed_keywords) has_success = any(keyword in res.text for keyword in success_keywords) is_success = res.status_code == 200 and (has_success or \u0026#34;location.href\u0026#34; in res.text) and not has_failed if is_success: print(f\u0026#34;\\033[7;32;47m登录成功! \\033[0m\u0026#34;) else: print(f\u0026#34;\\033[7;31;47m登录失败! {res.content.decode(\u0026#39;utf-8\u0026#39;)} \\033[0m\u0026#34;) print(\u0026#34;\\033[7;31;47m\u0026#34;, \u0026#34;请检查账号密码是否正确!\u0026#34;, \u0026#34;\\033[0m\u0026#34;) os.remove(file_name) print(\u0026#34;\\033[7;36;47m\u0026#34;, \u0026#34;已清除保存的账号信息。\\n请重新启动程序并输入正确的账号密码。\u0026#34;, \u0026#34;\\033[0m\u0026#34;) print(\u0026#34;按任意键退出...\u0026#34;) if ord(msvcrt.getch()): break except Exception as err: print(\u0026#34;\\033[7;31;47m\u0026#34;, \u0026#34;登录错误！\\t可能需要先连接WiFi？\u0026#34;, \u0026#34;\\033[0m\u0026#34;) print(\u0026#34;\\033[7;33;40m\u0026#34;, f\u0026#34;错误详情: {err}\u0026#34;, \u0026#34;\\033[0m\u0026#34;) print(\u0026#34;按 \u0026#39;R\u0026#39; 键重新尝试，或按任意键退出...\u0026#34;) if ord(msvcrt.getch()) != 114: break 脚本避免明文存储密码采用先哈希加密后保存到json的方式进行登录认证。\n在第一执行脚本时会在win临时目录下创建user_account.json文件来存储用户的用户名和加密后的密码信息。如果通过认证第二次执行脚本时会直接调取存储的信息。否则会删除json文件重新输入信息。运行结果如图：\n让脚本开机自动运行 Windows系统 在windows下有一个自启动文件夹：\n1 C:\\Users\\你的用户名称\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup 这个文件夹里放置的所有windows可识别文件都会在开机时自动执行。下面我们就使用这个文件夹进行部署。\npy文件直接部署 这是最简单的部署方法，前提电脑有python编译器支持。用bat批处理调用python编译器执行脚本：\n1 start python /“文件目录”/login_network.py 然后把bat文件放在前面说的Startup文件夹下即可。\nEXE部署 为了让没有python编译器也可以在任意windows系统运行。我们把py脚本打包成EXE可执行程序。但因为打包了python编译器，导致一个简单的脚本也需要很多mb的空间占用。\n首先python安装nuitka模块。\n1 pip install -U nuitka Nuitka是什么？\nnuitka是一个用来将python代码打包为exe可执行文件，方便其在没有相关环境的windows系统上运行的工具。其原理为：将python代码（自己写的部分）转换成C代码，以提高运行的速度。\n打包login_network.py为exe\n1 nuitka --onefile --include-package=requests --remove-output --assume-yes-for-downloads --output-filename=互联网自动认证登录.exe login_network.py 参数说明： \u0026ndash;onefile 打包为单个exe文件\n\u0026ndash;include-package=requests\t指定 requests 插件，确保 requests 库被正确打包\n\u0026ndash;remove-output 移除临时文件，减小最终文件大小\n\u0026ndash;assume-yes-for-downloads\t自动下载缺少的依赖\n\u0026ndash;output-filename=互联网自动认证登录.exe 打包完成后，会在当前目录生成互联网自动认证登录.exe文件\n可以看到我们用nuitka输出的exe文件。文件大小还是有点大的，本来5kb的代码打了个包变成了7.6Mb。\n打包完我们将代码放到自启动目录。无需其它操作，开机即可自行启动运行。\n","date":"2025-05-15T19:51:08+08:00","permalink":"https://n10dz.github.io/p/%E5%9F%BA%E4%BA%8Epython%E5%AE%9E%E7%8E%B0%E6%B7%B1%E4%BF%A1%E6%9C%8Dweb%E8%81%94%E7%BD%91%E8%AE%A4%E8%AF%81%E8%87%AA%E5%8A%A8%E7%99%BB%E5%BD%95/py%E8%84%9A%E6%9C%AC/","title":"基于python实现深信服Web联网认证自动登录/py脚本"},{"content":"本文针对麒麟、统信UOS、Ubuntu等Linux发行版中出现的/etc/resolv.conf文件被强制重置为127.0.0.53问题，提供两种解决方案。\n问题现象 麒麟系统无法上网，打不开网页。 手动修改/etc/resolv.conf后，重启系统或网络服务时配置被覆盖。 DNS服务器被强制设置为127.0.0.53（systemd-resolved服务地址）。 解决方案 一：临时修改DNS（重启后失效） 1 2 3 4 5 6 # 编辑DNS配置文件 sudo vim /etc/resolv.conf # 替换为以下内容（示例使用Google DNS） nameserver 8.8.8.8 nameserver 8.8.4.4 二：永久解决方案（推荐） 步骤1：停用systemd-resolved服务 1 2 sudo systemctl stop systemd-resolved sudo systemctl disable systemd-resolved 步骤2：安装unbound解析器 1 sudo apt update \u0026amp;\u0026amp; sudo apt install unbound -y 步骤3：配置NetworkManager 1 2 3 4 5 sudo vim /etc/NetworkManager/NetworkManager.conf #在 [main] 段落添加配置： ini dns=unbound 步骤4：应用配置 1 sudo systemctl restart NetworkManager 验证结果 1 2 cat /etc/resolv.conf # 应显示实际配置的DNS服务器 ping baidu.com # 测试网络连通性 📌技术原理 systemd-resolved 是新一代DNS解析服务，会强制接管DNS配置。本方案通过：\n用unbound替代默认解析器 修改NetworkManager的DNS管理策略 建立稳定的DNS配置托管机制 故障排查 如遇网络异常，可通过以下命令恢复： 1 2 sudo systemctl enable systemd-resolved --now sudo rm /etc/NetworkManager/conf.d/dns.conf 本文适用于以下国产信创系统： 麒麟Kylin V10 统信UOS 20 Ubuntu 18.04+/Debian 10+\n","date":"2025-03-20T16:45:00+08:00","permalink":"https://n10dz.github.io/p/%E8%A7%A3%E5%86%B3%E5%9B%BD%E4%BA%A7%E4%BF%A1%E5%88%9Blinux%E7%B3%BB%E7%BB%9Fdns%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%A2%AB%E5%BC%BA%E5%88%B6%E8%AE%BE%E7%BD%AE%E4%B8%BA127.0.0.53%E9%97%AE%E9%A2%98/","title":"解决国产信创Linux系统DNS服务器被强制设置为`127.0.0.53`问题"},{"content":"本文将详细记录我在Windows环境下使用Hugo静态网站生成器和GitHub Pages搭建个人博客的全过程，包含多分支管理策略和自动化部署方案。\n环境准备 1. 安装Hugo Extended 推荐使用扩展版Hugo以获得完整的SCSS支持：\n1 2 # 验证安装（需≥0.83.0） hugo version 2. 初始化Git仓库 1 2 3 hugo new site myblog cd myblog git init 主题配置 使用Stack主题（子模块方式） 1 2 git submodule add https://github.com/CaiJimmy/hugo-theme-stack/ themes/stack Copy-Item themes/stack/exampleSite/config.yaml ./config.yaml -Recurse 关键配置项：\n1 2 3 4 5 6 7 baseURL: \u0026#34;https://n10dz.github.io/\u0026#34; theme: stack params: sidebar: enabled: true social: GitHub: \u0026#34;https://github.com/n10dz/n10dz.github.io\u0026#34; 分支策略 采用双分支管理：\nmain 分支：存放Hugo源文件 gh-blog 分支：存放生成的静态页面 1 2 3 4 5 6 # 创建干净的分支 git checkout --orphan gh-blog git rm -rf . echo \u0026#34;# Blog Pages\u0026#34; \u0026gt; README.md git add . \u0026amp;\u0026amp; git commit -m \u0026#34;Init pages branch\u0026#34; git checkout -b main 部署流程 1. 推送源码到main分支 1 2 3 4 git remote add origin https://github.com/n10dz/n10dz.github.io.git git add . git commit -m \u0026#34;Initial commit\u0026#34; git push -u origin main 2. 生成并部署静态页面 1 2 3 4 5 6 7 8 hugo -D # 生成到public目录 cd public git init git checkout -b gh-blog git add . git commit -m \u0026#34;Deploy: $(date \u0026#34;+%Y-%m-%d %H:%M\u0026#34;)\u0026#34; git push origin gh-blog --force 自动化部署（可选） 在.github/workflows/deploy.yml添加GitHub Actions：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 name: Auto Deploy on: [push] jobs: build-deploy: runs-on: windows-latest steps: - uses: actions/checkout@v4 with: submodules: true - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#39;latest\u0026#39; extended: true - name: Build run: hugo --minify - name: Deploy uses: peaceiris/actions-gh-pages@v3 with: github_token: ${{ secrets.GITHUB_TOKEN }} publish_branch: gh-blog 注意事项 必须使用Hugo Extended版本 主题建议通过submodule方式引入 GitHub Pages的发布分支需要设置为gh-blog 每次更新内容后需要： 提交源码到main分支 重新生成并提交public目录到gh-blog分支 成果预览 访问你的GitHub Pages地址： https://n10dz.github.io\n至此，你已经拥有了一个完全免费、可自定义且支持自动化部署的现代博客系统。接下来可以开始创作你的技术文章啦！\n","date":"2022-02-20T15:32:00+08:00","permalink":"https://n10dz.github.io/p/%E5%9C%A8windows%E4%B8%8A%E4%BD%BF%E7%94%A8hugo-github-pages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%85%A8%E8%AE%B0%E5%BD%95/","title":"在Windows上使用Hugo+GitHub Pages搭建个人博客全记录"}]